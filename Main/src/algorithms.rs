
use dxfextract::PolyLine;

use egui::accesskit::DefaultActionVerb;
use log::{error, info, warn};
use pyo3::methods::IPowModulo;
use std::{collections::{HashMap, BTreeMap}, f64::consts::PI, vec, fmt, clone, default};

use crate::dxfextract;

const SMALLEST_ANGLE: f64 = 5.;
#[derive(Clone, Copy, PartialEq, Debug)]
pub struct Point {
    pub x: f64,
    pub y: f64,
}

//implementation of init, clone and angle between this and another point
impl Point {
    pub fn new(x: f64, y: f64) -> Self {
        Self {x, y}
    }
    pub fn clone(&self) -> Self { 
        *self
    }
    pub fn angle_to(&self, other: &Point) -> f64 {
        let dx = other.x - self.x;
        let dy = other.y - self.y;
        let angle = dy.atan2(dx);
        if angle < 0.0 {
            angle + 2.0 * PI
        } else {
            angle
        }
    }
}
//to_string implementation
impl fmt::Display for Point {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.write_str("(");
        fmt.write_str(&self.x.to_string());
        fmt.write_str(", ");
        fmt.write_str(&self.y.to_string());
        fmt.write_str(")");
        Ok(())
    }
}
#[derive(Clone, Copy, PartialEq)]
pub struct PointWithNeighbour {
    pub point: Point,
    pub neighbour: Point
}
#[derive(Clone, PartialEq)]
pub struct PointPolyline {
    pub point: Point,
    pub polyline: PolyLine,
    pub start: bool
}
impl PointPolyline {
    pub fn new(point: Point, polyline: PolyLine, start: bool) -> Self {
        Self {point, polyline, start}
    }
}
#[derive(Clone)]
pub struct Collector {
    pub pp1: PointPolyline,
    pub pp2: PointPolyline,
    pub min: f64
}
impl Collector {
    pub fn new(pp1: PointPolyline, pp2: PointPolyline, min: f64) -> Self {
        Self {pp1, pp2, min}
    }
}
/*impl PointWithNeighbour {
    pub fn new(point: CustomPoint, neighbour: CustomPoint) -> Self {
        Self {point, neighbour}
    }
    pub fn clone(&self) -> Self {
        *self
    }
}*/
//first try on finding intersection
/*fn intersection_of_points(a1: &CustomPoint, a2: &CustomPoint, b1: &CustomPoint, b2: &CustomPoint) -> CustomPoint{
    //y = mx + b
    let a_m = a2.y - a1.y / a2.x - a1.x;
    let a_b = a1.y - a_m * a1.x;
    let b_m = b2.y - b1.y / b2.x - b1.x;
    let b_b = b1.y - b_m * b1.x;

    //a_m * x + a_b = b_m * x + b_b

    let x = (b_b - a_b) / (a_m - b_m);
    let y = a_m * x + a_b;
    let new_point = CustomPoint::new(x, y);
    new_point
}*/
//second try on finding intersection. partially generated by ChatGPT

fn intersection(p1: &Point, p2: &Point, p3: &Point, p4: &Point) -> Option<Point> {
    let x1 = p1.x;
    let y1 = p1.y;
    let x2 = p2.x;
    let y2 = p2.y;
    let x3 = p3.x;
    let y3 = p3.y;
    let x4 = p4.x;
    let y4 = p4.y;

    //denominator
    let denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if denom == 0.0 {
        return None;
    }

    let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
    let _ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

    let x = x1 + ua * (x2 - x1);
    let y = y1 + ua * (y2 - y1);

    //reterns the position of the intersection
    Some(Point::new(x, y))
}
/*fn _find_closest_point(point: CustomPoint, vector: &Vec<PointWithNeighbour>) -> &PointWithNeighbour{
    let mut closest_point = vector.first().to_owned().unwrap();
    let mut closest_distance = f64::sqrt((closest_point.point.x - point.x) * (closest_point.point.x - point.x) + (closest_point.point.y - point.y) * (closest_point.point.y - point.y));
    for v_point in vector{
        let new_distance = f64::sqrt((v_point.point.x - point.x) * (v_point.point.x - point.x) + (v_point.point.y - point.y) * (v_point.point.y - point.y));
        if new_distance == 0. {
            continue;
        }
        if new_distance < closest_distance || closest_distance == 0. {
            closest_distance = new_distance;
            closest_point = v_point;
        }
    }
    closest_point
}*/
//returns the distance between two points
fn _distance(point_1x: &f64, point_1y: &f64, point_2x: &f64, point_2y: &f64) -> f64{
    f64::sqrt((point_1x - point_2x) * (point_1x - point_2x) + (point_1y - point_2y) * (point_1y - point_2y))
}
fn distance(point1: &Point, point2: &Point) -> f64 {
    f64::sqrt((point1.x - point2.x).powi(2) + (point1.y - point2.y).powi(2))
}

//angle at the point two linear functions intercept
//angle for two linear lines: angle = tan^-1 (|m2-m1|/(1+m1m2)) Where m1 is the slope of function A and m2 is the slope of function B
fn _angle_between_lines(m1: f64, m2: f64) -> f64{
    let angle = ((m2-m1)/(1.0+m1*m2)).abs().atan();
    angle * 180. / PI
}

//angle between vectors 
//angle = arccos((a*b)/|a||b|) -> where a*b is the dot product and |a| and |b| is the length of the vectors
fn _angle_vectors(v1: (f64, f64), v2: (f64, f64)) -> f64{
    //in a tuple the values are v1.0 and v1.1
    let length_v1 = ((v1.0 * v1.0) + (v1.1*v1.1)).sqrt(); //the length of a vector is |u| = sqrt(x^2+y^2)
    let length_v2 = ((v2.0*v2.0) + (v2.1*v2.1)).sqrt();

    let dotproduct = (v1.0*v2.0) + (v1.1*v2.1); //dot product of a 2D vector u*v = x1x2 + y1y2

    if length_v1 * length_v2 == 0.0{
        return 0.0
    }
    else {
        let angle = (dotproduct/(length_v1 * length_v2)).acos();
        angle * 180. / PI //return angle in degrees (f64)
    }
}

//B is the vertex where the angle is calculated
//function creates two vectors and uses the function angle vectors to return the angle
fn _angle_three_points(a: Point, b: Point, c: Point) -> f64{
    //creating vectors: AB and BC
    /*let ab = (a.0 - b.0, b.1 - a.1); //vector AB = (B1 - A1, B2 - A2)
    let bc = (c.0 - b.0, c.1 - b.1);

    let angle = angle_vectors(ab, bc);
    angle //return angle*/

    if a == b || a == c || b == c { //If two vertices are equal, return 0
        return 0.0
    }
    else{
        let angle_degrees = (180.0 / PI) * (b.angle_to(&a) - b.angle_to(&c)).abs();
        angle_degrees
    }

    
}
//handles both types of connections, extend and simple connect
pub fn connection_algorithm(extend: bool, all_layers: &BTreeMap<String, Vec<PolyLine>>, affected_layers: &BTreeMap<String, Vec<PolyLine>>, max_distance_in: &Option<f64>) -> BTreeMap<String, Vec<PolyLine>> {
    let max_distance;
    if let Some(distance) = max_distance_in.clone(){
        max_distance = distance;
    } 
    else {
        max_distance = 0.0;
    }
    
    let mut current_map = BTreeMap::<String, Vec<PolyLine>>::new();
    for(name, polylines) in all_layers{
        //skips layers that shouldnt be edited
        if !affected_layers.contains_key(name){
            continue;
        }
        let mut out_polylines = Vec::<PolyLine>::default();
        let mut cur_polylines = Vec::<PolyLine>::default();
        let mut points = Vec::<PointPolyline>::default();
        //adds all the open endpoints to a collection
        for polyline in polylines {
            if polyline.is_closed{
                out_polylines.push(polyline.clone());
                continue;
            }
            cur_polylines.push(polyline.clone());
            points.push(PointPolyline::new(Point::new(polyline.x_values.first().unwrap().clone(), polyline.y_values.first().unwrap().clone()), polyline.clone(), true));
            points.push(PointPolyline::new(Point::new(polyline.x_values.last().unwrap().clone(), polyline.y_values.last().unwrap().clone()), polyline.clone(), false));
        }
        if points.len() > 0 {
            //find the 2 closest open points in the layer
            let col = closest(&points);
            //increases efficiency when using a max distance
            if col.min > max_distance {
                for polyline in cur_polylines {
                    out_polylines.push(polyline);
                }
            }
            else {
            let mut x_val;
            let mut y_val;
            let start_pp;
            let end_pp;
            
            if !col.pp1.start && col.pp2.start {
                start_pp = col.pp2.clone();
                end_pp = col.pp1.clone();
            }
            else {
                start_pp = col.pp1.clone();
                end_pp = col.pp2.clone();
            }
            let is_closed = start_pp.polyline == end_pp.polyline;

            if start_pp.start {
                x_val = reverse_vector(start_pp.polyline.x_values);
                y_val = reverse_vector(start_pp.polyline.y_values);
            }
            //case that happens when both are endpoints
            else {
                //println!("End");
                x_val = start_pp.polyline.x_values;
                y_val = start_pp.polyline.y_values;
            }
            let mut remove = false;
            let merge = start_pp.point == end_pp.point;
            //triangles being edgecases
            let mut is_triangle = false;
            if merge{
                x_val.pop();
                y_val.pop();
            }
            //special case when extending instead of connecting. no need to run this if the points are ontop each other
            else if extend{
                //second point from the startpoint
                let s_point = Point::new(x_val[x_val.len() - 2], y_val[x_val.len() - 2]);
                //second point from endpoint
                let e_point;
                let temp_x = end_pp.polyline.x_values.clone();
                let temp_y = end_pp.polyline.y_values.clone();
                if end_pp.start {
                    e_point = Point::new(temp_x[1], temp_y[1]);
                }
                else {
                    e_point = Point::new(temp_x[temp_x.len() - 2], temp_y[temp_x.len() - 2]);
                }
                let inter = intersection(&start_pp.point, &s_point, &end_pp.point, &e_point);
                if let Some(i_point) = inter {
                    //makes sure the angle and distance works for this file, uses connect instead if not. also makes sure triangles closes as they should
                    is_triangle = i_point == s_point || i_point == e_point;
                    if !(distance(&i_point, &start_pp.point) > max_distance) && !is_triangle {
                        remove = true;
                        x_val.pop();
                        y_val.pop();
                        x_val.push(i_point.x);
                        y_val.push(i_point.y);
                    }
                }
                
            }
            //edge case when using extend to close itself
            if extend && is_closed && !merge && !is_triangle{
                x_val = reverse_vector(x_val);
                y_val = reverse_vector(y_val);
                x_val.pop();
                y_val.pop();
            }
            //ensure there is no doubles when connecting with itself
            if !is_closed {
                if end_pp.start {
                    let mut vec_x = end_pp.polyline.x_values.clone();
                    let mut vec_y = end_pp.polyline.y_values.clone();
                    if remove{
                        vec_x = reverse_vector(vec_x);
                        vec_y = reverse_vector(vec_y);
                        vec_x.pop();
                        vec_y.pop();
                        vec_x = reverse_vector(vec_x);
                        vec_y = reverse_vector(vec_y);
                    }
                    x_val.append(&mut vec_x.clone());
                    y_val.append(&mut vec_y.clone());
                }
                else{
                    let mut vec_x = end_pp.polyline.x_values.clone();
                    let mut vec_y = end_pp.polyline.y_values.clone();
                    if remove{
                        vec_x.pop();
                        vec_y.pop();
                    }
                    x_val.append(&mut reverse_vector(vec_x));
                    y_val.append(&mut reverse_vector(vec_y));
                }
            }
            cur_polylines.retain(|x| x != &col.pp1.polyline);
            cur_polylines.retain(|x| x != &col.pp2.polyline);
            let new_polyline = PolyLine::new(is_closed.clone(), x_val.clone(), y_val.clone());
            cur_polylines.push(new_polyline);
            for polyline in cur_polylines {
                out_polylines.push(polyline);
            }
            }
            
        }
        current_map.insert(name.clone(), out_polylines);
    }
    
    for (name, layer) in all_layers {
        if affected_layers.contains_key(name){
            continue;
        }
        current_map.insert(name.clone(), layer.clone());
    }
    current_map
}
//function that connects polylines inside of each layer depending on the parameters given. O(n^2) so needs optimizing later down the line
// this is legacy

//finds and returns the min and max x and y for a given map
pub fn calculate_min_max(layer_polylines: &BTreeMap<String, Vec<PolyLine>>) -> Option<(f64, f64, f64, f64, f64)>{
    let all_polylines: Vec<PolyLine> = layer_polylines
        .values()
        .flat_map(|v| v.iter().cloned())
        .collect();

    // compute stats for polylines
    let x_values: Vec<f64> = all_polylines
        .iter()
        .flat_map(|e| e.x_values.clone())
        .collect();

    let y_values: Vec<f64> = all_polylines
        .iter()
        .flat_map(|e| e.y_values.clone())
        .collect();

    let cmp = |a: &f64, b: &f64| f64::partial_cmp(a, b).unwrap();
   

    if !(x_values.len() > 0 && y_values.len() > 0){
        None //Return none if there is no values in BTreeMap
    }
    else{
        //Can only unwrap if values exist
        let min_x = x_values.iter().copied().min_by(cmp).unwrap();
        let max_x = x_values.iter().copied().max_by(cmp).unwrap();
        let min_y = y_values.iter().copied().min_by(cmp).unwrap();
        let max_y = y_values.iter().copied().max_by(cmp).unwrap();

        // create document
        let width = max_x - min_x;
        let height = max_y - min_y;
        Some((min_x, min_y, max_y, width, height))
    }
    
}

//creates a flipped copy of a given vector - ineffecient, should be flagged
pub fn reverse_vector(mut vector: Vec<f64>) -> Vec<f64>{
    let mut out = Vec::<f64>::default();
    while let Some(val) = vector.pop(){
        out.push(val);
    }
    out
}

//brute force checks all
//O(n^2)
fn brute(points: &Vec<PointPolyline>) -> Collector{
    let mut min = f64::MAX;
    let size = points.len();
    let mut current = None;
    for i in 0..size {
        for j in i+1..size{
            let point1 = &points[i];
            let point2 = &points[j];
            let distance = distance(&point1.point, &point2.point);
            if distance < min {
                min = distance;
                current = Some(Collector::new(point1.clone(), point2.clone(), min.clone()));
            }
        }
    }
    current.unwrap()
}
fn strip(points: &Vec<PointPolyline>, d: &Collector) -> Collector{
    let mut strip = points.clone();
    let mut min = d.min.clone();
    let size = strip.len();
    //println!("size: {}", size);
    let mut current = d.clone();
    strip.sort_by(|a, b| a.point.y.partial_cmp(&b.point.y).unwrap());

    for i in 0..size {
        let x = i+1;
        //println!("{}", i);
        for j in x..size {
            //println!("{} {}", i, j);
            if (strip[j].point.y - strip[i].point.y) > min {
                break;
            }
            let point1 = &strip[i];
            let point2 = &strip[j];
            let distance = distance(&point1.point, &point2.point);
            
            if distance < min {
                min = distance;
                //println!("Overwriting");
                current = Collector::new(point1.clone(), point2.clone(), min.clone());
            }
        }
    }
    current
}
fn closest_util(points: &Vec<PointPolyline>, start: usize, end: usize) -> Collector{
    if (end - start) <= 3 {
        //println!("Bruting");
        return brute(points);
    }
    //println!("Start: {} End: {}", start, end);
    let mid = start + (end - start) / 2;
    let mid_point = points[mid].clone();
    let dl = closest_util(points, start, mid);
    let dr = closest_util(points, mid, end);
    let d;
    if dl.min < dr.min {
        d = dl;
    }
    else {
        d = dr;
    }
    let mut strip_points = Vec::<PointPolyline>::default();
    for i in 0..end {
        if (points[i].point.x - mid_point.point.x) < d.min {
            //println!("{}", points[i].point.x);
            strip_points.push(points[i].clone());
        }
    } 
    let temp = strip(&strip_points, &d);
    Collector::new(temp.pp1, temp.pp2, temp.min.min(d.min))
}
fn closest(in_points: &Vec<PointPolyline>) -> Collector{
    let mut points = in_points.clone();
    points.sort_by(|a, b| a.point.x.partial_cmp(&b.point.x).unwrap());
    for point in &points {
        //println!("{}", point.point);
    }
    closest_util(&points, 0 as usize, points.len())
}
pub fn connection_algorithm_legacy(extend: bool, all_layers: &BTreeMap<String, Vec<PolyLine>>, affected_layers: &BTreeMap<String, Vec<PolyLine>>, max_distance_in: &Option<f64>, max_angle_in: &Option<i32>, o_iterations: &Option<i32>) -> BTreeMap<String, Vec<PolyLine>> {
    let mut out = all_layers.clone();
    let mut iterations;
    let mut done_iterations = 0;
    let mut any_changes = true;
    let max_distance;
    //currently not used, but may have use for limiting angles
    let _max_angle;
    if let Some(amount) = o_iterations.clone(){
        iterations = amount;
    }
    else{
        iterations = 1;
    }
    if let Some(angle) = max_angle_in.clone(){
        _max_angle = angle;
    }
    else{
        _max_angle = 180;
    }
    if let Some(distance) = max_distance_in.clone(){
        max_distance = distance;
    } 
    else {
        max_distance = 0.0;
    }
    //stops if max iterations has been reached, or there were no changes in the previous iteration
    while &iterations > &0 && any_changes {
        iterations -= 1;
        done_iterations += 1;
        any_changes = false;
        let mut current_map = BTreeMap::<String, Vec<PolyLine>>::new();
        for(name, polylines) in &out{
            if !affected_layers.contains_key(name){
                continue;
            }
            let mut out_polylines = Vec::<PolyLine>::default();
            let mut iter = polylines.clone();
            let mut has_changed = Vec::<PolyLine>::default();
            
            while let Some(mut polyline) = iter.pop(){
                if has_changed.contains(&polyline){
                    continue;
                }
                if polyline.is_closed{
                    out_polylines.push(polyline);
                    continue;
                }
                let start_x = polyline.x_values.first().unwrap();
                let start_y = polyline.y_values.first().unwrap();
                let end_x = polyline.x_values.last().unwrap();
                let end_y = polyline.y_values.last().unwrap();
                let start_distance = _distance(start_x, start_y, end_x, end_y);
                let mut min_distance_start = start_distance.clone();
                let mut min_distance_end = start_distance.clone();
                let mut should_close = true;
                let mut start_connection = None;
                let mut end_connection = None;
            
                //handles different edge cases. literally
                let mut start_is_start = false;
                let mut end_is_start = false;
                //iterates through the polylines in the collection. skips itself as well as closed polylines
                for cmp_polyline in polylines{
                    //doesnt interact with closed polylines nor itself
                    if cmp_polyline.is_closed || cmp_polyline.clone() == polyline.clone(){
                        continue;
                    }
                    
                    let cmp_start_x = cmp_polyline.x_values.first().unwrap();
                    let cmp_start_y = cmp_polyline.y_values.first().unwrap();
                    let cmp_end_x = cmp_polyline.x_values.last().unwrap();
                    let cmp_end_y = cmp_polyline.y_values.last().unwrap();
                    
                    //checks startpoint of selected polyline
                    //against startpoint of current
                    let mut cur_distance = _distance(start_x, start_y, cmp_start_x, cmp_start_y);
                    if cur_distance < min_distance_start && cur_distance <= max_distance{
                        min_distance_start = cur_distance;
                        start_connection = Some(cmp_polyline);
                        start_is_start = true;
                    }
                    //against endpoint of current
                    cur_distance = _distance(start_x, start_y, cmp_end_x, cmp_end_y);
                    if cur_distance < min_distance_start && cur_distance <= max_distance{
                        
                        min_distance_start = cur_distance;
                        start_connection = Some(cmp_polyline);
                        start_is_start = false;
                    }
                    //min_distance = start_distance;
    
                    //checks endpoint of selected polyline
                    //against startpoint of current
                    cur_distance = _distance(end_x, end_y, cmp_start_x, cmp_start_y);
                    if cur_distance < min_distance_end && cur_distance <= max_distance{
                        
                        min_distance_end = cur_distance;
                        end_connection = Some(cmp_polyline);
                        end_is_start = true;
                    }
                    //against endpoint of current
                    cur_distance = _distance(end_x, end_y, cmp_end_x, cmp_end_y);
                    if cur_distance < min_distance_end && cur_distance <= max_distance{
                        
                        min_distance_end = cur_distance;
                        end_connection = Some(cmp_polyline);
                        end_is_start = false;
                    }
                }
                //skips cases where they are not each others closest // hard to make it optimal // need to come up with something better
                /* 
                if let Some(remove_start) = start_connection {
                    let mut min_distance = i32::MAX;
                    for cmp_polyline in polylines {
                        if cmp_polyline.is_closed || cmp_polyline.clone() == remove_start.clone(){
                            continue;
                        }
                        let cmp_start_x = cmp_polyline.x_values.first().unwrap();
                        let cmp_start_y = cmp_polyline.y_values.first().unwrap();
                        let cmp_end_x = cmp_polyline.x_values.last().unwrap();
                        let cmp_end_y = cmp_polyline.y_values.last().unwrap();
                        let cur_distance = distance(end_x, end_y, cmp_end_x, cmp_end_y);
                    }
                }*/
                
                if let (Some(remove_start), Some(remove_end)) = (start_connection, end_connection) {
                    should_close = false;
                    any_changes = true;
                    //println!("case1");
                    if has_changed.contains(remove_end) || has_changed.contains(remove_start) {
                        out_polylines.push(polyline.clone());
                        continue;
                    }
                    
                    has_changed.push(remove_start.clone());
                    has_changed.push(remove_end.clone());
                    if extend {
                        let mut last_point_1;
                        let mut last_point_2;
                        let mut second_last_point_1;
                        let mut second_last_point_2;
                        let mut new_x_values;
                        let mut new_y_values;
                        if start_is_start {
                            new_x_values = reverse_vector(remove_start.x_values.clone());
                            new_y_values = reverse_vector(remove_start.y_values.clone());
                            last_point_1 = Point::new(new_x_values.pop().unwrap(), new_y_values.pop().unwrap());
                            second_last_point_1 = Point::new(new_x_values.last().unwrap().clone(), new_y_values.last().unwrap().clone());
                        }
                        else{
                            new_x_values = remove_start.x_values.clone();
                            new_y_values = remove_start.y_values.clone();
                            last_point_1 = Point::new(new_x_values.pop().unwrap(), new_y_values.pop().unwrap());
                            second_last_point_1 = Point::new(new_x_values.last().unwrap().clone(), new_y_values.last().unwrap().clone());
                        }
                        let mut polyline_values_x = reverse_vector(polyline.x_values.clone());
                        let mut polyline_values_y = reverse_vector(polyline.y_values.clone());
                        last_point_2 = Point::new(polyline_values_x.pop().unwrap(), polyline_values_y.pop().unwrap());
                        second_last_point_2 = Point::new(polyline_values_x.last().unwrap().clone(), polyline_values_y.last().unwrap().clone());
                        let mut interception = Point::new(0., 0.);
                        if let Some(found_point) = intersection(&last_point_1, &second_last_point_1, &last_point_2, &second_last_point_2){
                            interception = found_point;
                        }
                        /*let angle = angle_three_points(last_point_1, interception, last_point_2);
                        println!("{}", angle);*/
                        new_x_values.push(interception.x);
                        new_y_values.push(interception.y);
                        new_x_values.append(&mut reverse_vector(polyline_values_x));
                        new_y_values.append(&mut reverse_vector(polyline_values_y));
                        last_point_1 = Point::new(new_x_values.pop().unwrap(), new_y_values.pop().unwrap());
                        second_last_point_1 = Point::new(new_x_values.last().unwrap().clone(), new_y_values.last().unwrap().clone());
                        let mut remove_x_values = remove_end.x_values.clone();
                        let mut remove_y_values = remove_end.y_values.clone();

                        if end_is_start {
                            remove_x_values = reverse_vector(remove_x_values);
                            remove_y_values = reverse_vector(remove_y_values);
                            last_point_2 = Point::new(remove_x_values.pop().unwrap(), remove_y_values.pop().unwrap());
                            second_last_point_2 = Point::new(remove_x_values.last().unwrap().clone(), remove_y_values.last().unwrap().clone());
                            remove_x_values = reverse_vector(remove_x_values);
                            remove_y_values = reverse_vector(remove_y_values);
                        }
                        else{
                            last_point_2 = Point::new(remove_x_values.pop().unwrap(), remove_y_values.pop().unwrap());
                            second_last_point_2 = Point::new(remove_x_values.last().unwrap().clone(), remove_y_values.last().unwrap().clone());
                            remove_x_values = reverse_vector(remove_x_values);
                            remove_y_values = reverse_vector(remove_y_values);
                        }
    
                        if let Some(found_point) = intersection(&last_point_1, &second_last_point_1, &last_point_2, &second_last_point_2){
                            interception = found_point;
                        }
                        /*let angle = angle_three_points(last_point_1, interception, last_point_2);
                        println!("{}", angle);*/
                        //interception = (interception_of_points(&last_point_1, &second_last_point_1, &last_point_2, &second_last_point_2));
                        new_x_values.push(interception.x);
                        new_y_values.push(interception.y);
                        let closed = remove_start == remove_end;
                        if !closed {
                            new_x_values.append(&mut remove_x_values);
                            new_y_values.append(&mut remove_y_values);
                        }
                        
                        
                        //println!("Case1 X-length: {}, Y-length: {}", new_x_values.len(), new_y_values.len());
                        out_polylines.push(PolyLine::new(closed, new_x_values, new_y_values));
                    }
                    //connect
                    else{
                        let mut new_x_values;
                        let mut new_y_values;
                        if start_is_start {
                            new_x_values = reverse_vector(remove_start.x_values.clone());
                            new_y_values = reverse_vector(remove_start.y_values.clone());
                        }
                        else{
                            new_x_values = remove_start.x_values.clone();
                            new_y_values = remove_start.y_values.clone();
                        }
                        new_x_values.append(&mut polyline.x_values.clone());
                        new_y_values.append(&mut polyline.y_values.clone());
                        
                        let closed = remove_start == remove_end;
                        if !closed{
                            if end_is_start {
                                new_x_values.append(&mut remove_end.x_values.clone());
                                new_y_values.append(&mut remove_end.y_values.clone());
                            }
                            else{
                                new_x_values.append(&mut reverse_vector(remove_end.x_values.clone()));
                                new_y_values.append(&mut reverse_vector(remove_end.y_values.clone()));
                            }
                        }
                        out_polylines.push(PolyLine::new(closed, new_x_values, new_y_values));
                    }
                    
                }
                
                else if let Some(remove) = start_connection {
                    should_close = false;
                    any_changes = true;
                    //println!("case2");
                    //waits for next iteration
                    if has_changed.contains(remove){
                        out_polylines.push(polyline.clone());
                        continue;
                    }
                    has_changed.push(remove.clone());
                    if extend {
                        let last_point_1;
                        let last_point_2;
                        let second_last_point_1;
                        let second_last_point_2;
                        let mut new_x_values;
                        let mut new_y_values;
                        if start_is_start {
                            new_x_values = reverse_vector(remove.x_values.clone());
                            new_y_values = reverse_vector(remove.y_values.clone());
                            last_point_1 = Point::new(new_x_values.pop().unwrap(), new_y_values.pop().unwrap());
                            second_last_point_1 = Point::new(new_x_values.last().unwrap().clone(), new_y_values.last().unwrap().clone());
                        }
                        else{
                            new_x_values = remove.x_values.clone();
                            new_y_values = remove.y_values.clone();
                            last_point_1 = Point::new(new_x_values.pop().unwrap(), new_y_values.pop().unwrap());
                            second_last_point_1 = Point::new(new_x_values.last().unwrap().clone(), new_y_values.last().unwrap().clone());
                        }
                        let mut polyline_values_x = reverse_vector(polyline.x_values.clone());
                        let mut polyline_values_y = reverse_vector(polyline.y_values.clone());
                        last_point_2 = Point::new(polyline_values_x.pop().unwrap(), polyline_values_y.pop().unwrap());
                        second_last_point_2 = Point::new(polyline_values_x.last().unwrap().clone(), polyline_values_y.last().unwrap().clone());
                        let mut interception = Point::new(0., 0.);
                        if let Some(found_point) = intersection(&last_point_1, &second_last_point_1, &last_point_2, &second_last_point_2){
                            interception = found_point;
                        }
                        /*let angle = angle_three_points(last_point_1, interception, last_point_2);
                        println!("{}", angle);*/
                        new_x_values.push(interception.x);
                        new_y_values.push(interception.y);
                        new_x_values.append(&mut reverse_vector(polyline_values_x));
                        new_y_values.append(&mut reverse_vector(polyline_values_y));
                        //println!("Case2 X-length: {}, Y-length: {}", new_x_values.len(), new_y_values.len());
                        out_polylines.push(PolyLine::new(false, new_x_values, new_y_values));
                    }
                    else {
                        if start_is_start{
                            let mut new_x_values = reverse_vector(polyline.x_values.clone());
                            new_x_values.append(&mut remove.x_values.clone());
                            let mut new_y_values = reverse_vector(polyline.y_values.clone());
                            new_y_values.append(&mut remove.y_values.clone());
                            
                            out_polylines.push(PolyLine::new(false, new_x_values, new_y_values));
                        }
                        else{
                            let mut new_x_values = reverse_vector(polyline.x_values.clone());
                            new_x_values.append(&mut reverse_vector(remove.x_values.clone()));
                            let mut new_y_values = reverse_vector(polyline.y_values.clone());
                            new_y_values.append(&mut reverse_vector(remove.y_values.clone()));
                            
                            out_polylines.push(PolyLine::new(false, new_x_values, new_y_values));
                        }
                    }
                    
                }
                else if let Some(remove) = end_connection {
                    //skips this connection if the connector already has been used this iteration
                    //println!("case3");
                   
                    
                    should_close = false;
                    any_changes = true;
                    if has_changed.contains(remove){
                        out_polylines.push(polyline.clone());
                        continue;
                    }
                    has_changed.push(remove.clone());
                    if extend {
                        let last_point_1;
                        let last_point_2;
                        let second_last_point_1;
                        let second_last_point_2;
                        let mut new_x_values = polyline.x_values.clone();
                        let mut new_y_values = polyline.y_values.clone();
                        last_point_1 = Point::new(new_x_values.pop().unwrap(), new_y_values.pop().unwrap());
                        second_last_point_1 = Point::new(new_x_values.last().unwrap().clone(), new_y_values.last().unwrap().clone());
                        let mut remove_x_values = remove.x_values.clone();
                        let mut remove_y_values = remove.y_values.clone();
                        if end_is_start {
                            remove_x_values = reverse_vector(remove_x_values);
                            remove_y_values = reverse_vector(remove_y_values);
                            last_point_2 = Point::new(remove_x_values.pop().unwrap(), remove_y_values.pop().unwrap());
                            second_last_point_2 = Point::new(remove_x_values.last().unwrap().clone(), remove_y_values.last().unwrap().clone());
                            remove_x_values = reverse_vector(remove_x_values);
                            remove_y_values = reverse_vector(remove_y_values);
                        }
                        else{
                            last_point_2 = Point::new(remove_x_values.pop().unwrap(), remove_y_values.pop().unwrap());
                            second_last_point_2 = Point::new(remove_x_values.last().unwrap().clone(), remove_y_values.last().unwrap().clone());
                            remove_x_values = reverse_vector(remove_x_values);
                            remove_y_values = reverse_vector(remove_y_values);
                        }
                        let mut interception = Point::new(0., 0.);
                        if let Some(found_point) = intersection(&last_point_1, &second_last_point_1, &last_point_2, &second_last_point_2){
                            interception = found_point;
                        }
                        /*let angle = angle_three_points(last_point_1, interception, last_point_2);
                        println!("{}", angle);*/
                        //interception = (interception_of_points(&last_point_1, &second_last_point_1, &last_point_2, &second_last_point_2));
                        new_x_values.push(interception.x);
                        new_y_values.push(interception.y);
                        new_x_values.append(&mut remove_x_values);
                        new_y_values.append(&mut remove_y_values);
                        //println!("Case3 X-length: {}, Y-length: {}", new_x_values.len(), new_y_values.len());
                        out_polylines.push(PolyLine::new(false, new_x_values, new_y_values));
                    }
                    else {
                        if end_is_start{
                            let mut new_x_values = polyline.x_values.clone();
                            new_x_values.append(&mut remove.x_values.clone());
                            let mut new_y_values = polyline.y_values.clone();
                            new_y_values.append(&mut remove.y_values.clone());
                            
                            out_polylines.push(PolyLine::new(false, new_x_values, new_y_values));
                        }
                        else{
                            let mut new_x_values = polyline.x_values.clone();
                            new_x_values.append(&mut reverse_vector(remove.x_values.clone()));
                            let mut new_y_values = polyline.y_values.clone();
                            new_y_values.append(&mut reverse_vector(remove.y_values.clone()));
                            
                            out_polylines.push(PolyLine::new(false, new_x_values, new_y_values));
                        }
                    }
                    
                }
    
                //If the closest point is part of the same polyline
                if should_close {
                    //println!("closing {}, {}, {}", polyline.x_values.len(), start_distance, max_distance);
                    polyline.is_closed = polyline.x_values.len() != 2 && start_distance <= max_distance;
                    //polyline.x_values.pop();
                    //polyline.y_values.pop();
                    out_polylines.push(polyline);
                    //println!("\n closest point is part of same polyline..");
                    //out_polylines.push(PolyLine::new(true, polyline.x_values.clone(), polyline.y_values.clone()));
                    continue;
                }
                
            }
            current_map.insert(name.clone(), out_polylines);
        }
        info!("Iterations executed: {}, Type: Connect", done_iterations);
        for (name, layer) in all_layers {
            if affected_layers.contains_key(name){
                continue;
            }
            current_map.insert(name.clone(), layer.clone());
        }
        out = current_map;
    }
out
}

#[cfg(test)]
mod tests {
    //use tracing_subscriber::layer;

    use super::*;
    #[test]
    fn test_revers_vector() {
        //Test case 1: Empty vector
        let vector1: Vec<f64> = vec![];
        let expected_output1: Vec<f64> = vec![];
        assert_eq!(reverse_vector(vector1), expected_output1);

        // Test case 2: Test with vector of single element
        let vector2: Vec<f64> = vec![1.0];
        let expected_output2: Vec<f64> = vec![1.0];
        assert_eq!(reverse_vector(vector2), expected_output2);

        // Test case 3: Test with vector of multiple elements
        let vector3: Vec<f64> = vec![1.0, 2.0, 3.0, 4.0];
        let expected_output3: Vec<f64> = vec![4.0, 3.0, 2.0, 1.0];
        assert_eq!(reverse_vector(vector3), expected_output3);
    }

    #[test]
    fn test_calculate_min_max(){
        //Sample data set
        let mut layer_polylines = BTreeMap::new();


        let x1_values = vec![1.0, 2.0, 3.0, 4.0];
        let y1_values = vec![1.0, 2.0, 3.0, 4.0];

        let x2_values = vec![5.0, 6.0, 7.0, 8.0];
        let y2_values = vec![5.0, 6.0, 7.0, 8.0];

        let x3_values = vec![-1.0, -2.0, -3.0, -4.0];
        let y3_values = vec![-1.0, -2.0, -3.0, -4.0];

        let polyline1 = PolyLine::new(false, x1_values, y1_values);
        let polyline2 = PolyLine::new(false, x2_values, y2_values);
        let polyline3 = PolyLine::new(false, x3_values, y3_values);

        layer_polylines.insert(String::from("layer1"), vec![polyline1, polyline2]);
        layer_polylines.insert(String::from("layer2"), vec![polyline3]);

        //Test case 1 : BTreeMap is empty
        let empty: BTreeMap<String, Vec<PolyLine>> = BTreeMap::new();
        assert!(calculate_min_max(&empty).is_none());

        //Test case 2 : Non-Empty, use the sample data
        let expected = (-4.0, -4.0, 8.0, 12.0, 12.0); //(min_x, min_y, max_y, width, height)
        assert_eq!(calculate_min_max(&layer_polylines).unwrap(), expected);


    }

    #[test]
    fn test_distance(){
        //Test case 1: Points are equal => Distance should be zero
        let p1 = Point::new(2.0, 2.0);
        let p2 = Point::new(2.0, 2.0);
        let expected_result = 0.0;
        let result = _distance(&p1.x, &p1.y, &p2.x, &p2.y);

        assert_eq!(result, expected_result);

        //Test case 2: Distance only on X-axis
        let p1 = Point::new(0.0, 2.0);
        let p2 = Point::new(2.0, 2.0);
        let expected_result = 2.0;
        let result = _distance(&p1.x, &p1.y, &p2.x, &p2.y);

        assert_eq!(result, expected_result);

        //Test case 3: Distance only on Y-axis
        let p1 = Point::new(2.0, 0.0);
        let p2 = Point::new(2.0, 2.0);
        let expected_result = 2.0;
        let result = _distance(&p1.x, &p1.y, &p2.x, &p2.y);

        assert_eq!(result, expected_result);

        //Test case 4: Distance on both axis
        let p1 = Point::new(1.0, 2.0);
        let p2 = Point::new(4.0, 6.0);
        let expected_result = 5.0;
        let result = _distance(&p1.x, &p1.y, &p2.x, &p2.y);

        assert_eq!(result, expected_result);

    }

    #[test]
    fn test_angle_between_lines(){
        //m1 is slope of function x, m2 is slope of function g
        
        //Test case 1: Line with equal slope
        let m1 = 2.0;
        let m2 = 2.0;
        let expected_result = 0.0;
        let result = _angle_between_lines(m1, m2);

        assert_eq!(result, expected_result);

        //Test case 2: Slope is zero
        let m1 = 0.0;
        let m2 = 0.0;
        let expected_result = 0.0;
        let result = _angle_between_lines(m1, m2);

        assert_eq!(result, expected_result);

        //Test case 3: Arbitrary slope
        let m1 = 2.0;
        let m2 = -3.0;
        let expected_result = 45.0; 
        let result = _angle_between_lines(m1, m2);

        assert_eq!(result, expected_result);



    }

    #[test]
    fn test_intersection(){
        //Test case 1: Two lines intersect at point (3.0, 3.0)
        let p1 = Point::new(2.0, 2.0);
        let p2 = Point::new(4.0, 4.0);
        let p3 = Point::new(2.0, 4.0);
        let p4 = Point::new(4.0, 2.0);
        let expected_result = Some(Point::new(3.0, 3.0));
        
        assert_eq!(intersection(&p1, &p2, &p3, &p4), expected_result);

        //Test case 2: Two lines are parallel => do not intersect
        let p1 = Point::new(2.0, 2.0);
        let p2 = Point::new(3.0, 3.0);
        let p3 = Point::new(4.0, 4.0);
        let p4 = Point::new(5.0, 5.0);

        assert!(intersection(&p1, &p2, &p3, &p4).is_none());
    }

    #[test]
    fn test_angle_vectors(){
        //Test case 1: Length of both vectors is zero
        let v1 = (0.0, 0.0);
        let v2 = (0.0, 0.0);
        let expected_result = 0.0;
        let result = _angle_vectors(v1, v2);

        assert_eq!(result, expected_result);

        //Test case 2: Parallel vectors
        let v1 = (1.0, 0.0);
        let v2 = (2.0, 0.0);
        let expected_result = 0.0;
        let result = _angle_vectors(v1, v2);

        assert_eq!(result, expected_result);

        //Test case 3: Arbitrary vectors
        let v1 = (1.0, 2.0);
        let v2 = (3.0, 1.0);
        let expected_result = 45.0;
        let result = _angle_vectors(v1, v2);
        const EPSILON: f64 = 1e-6; //Accuracy on angle 
        

        assert!((result - expected_result).abs() < EPSILON)


    }
    

    #[test]
    fn test_angle_three_points(){
        //Create three helper points
        //Test case 1: Three different points
        let p1 = Point::new(1.0, 0.0);
        let p2 = Point::new(0.0, 0.0);
        let p3 = Point::new(0.0, 1.0);
        let result = _angle_three_points(p1,p2, p3);
        let expected_result = 90.0;
        const EPSILON: f64 = 1e-6; //Accuracy on angle 

        assert!((result - expected_result).abs() < EPSILON);

        //Test case 2: Three equals points
        let p1 = Point::new(1.0, 1.0);
        let p2 = Point::new(1.0, 1.0);
        let p3 = Point::new(1.0, 1.0);
        let result = _angle_three_points(p1,p2, p3);
        let expected_result = 0.0;

        assert_eq!(result, expected_result);

        //Test case 3: Two points equal
        let p1 = Point::new(0.0, 0.0);
        let p2 = Point::new(2.0, 1.0);
        let p3 = Point::new(2.0, 1.0);
        let result = _angle_three_points(p1,p2, p3);
        let expected_result = 0.0;

        assert_eq!(result, expected_result);

    }
    #[test]
    fn test_extend_polylines(){
        //Create a Sample data set
        //BTreeMap
        let mut test_layers: BTreeMap<String, Vec<PolyLine>> = BTreeMap::new();
        let mut test_affected_layers: BTreeMap<String, Vec<PolyLine>> = BTreeMap::new();

        //Random line
        let x1_values = vec![1.0, 2.0, 2.0, 2.0, 1.0]; 
        let y1_values = vec![1.0, 1.0, 2.0, 3.0, 3.0];
        let polyline1 = PolyLine::new(false, x1_values, y1_values);

        //Start is start
        let x2_values = vec![1.0, 2.0, 3.0]; 
        let y2_values = vec![1.0, 1.0, 1.0];
        let start_is_start = PolyLine::new(false, x2_values, y2_values);

        //Start is end
        let x5_values = vec![3.0, 2.0, 1.0]; 
        let y5_values = vec![1.0, 1.0, 1.0];
        let start_is_end = PolyLine::new(false, x5_values, y5_values);

        //End is start
        let x3_values = vec![4.0, 5.0, 6.0]; 
        let y3_values = vec![2.0, 3.0, 3.0];
        let end_is_start = PolyLine::new(false, x3_values, y3_values);

        //End is end
        let x4_values = vec![6.0, 5.0, 4.0]; 
        let y4_values = vec![3.0, 3.0, 2.0];
        let end_is_end = PolyLine::new(false, x4_values, y4_values);

        let mut expected: BTreeMap<String, Vec<PolyLine>> = BTreeMap::new();

        //Test case 0: Only 1 iteration => line should give correct values, but is_closed = false
        test_layers.insert(String::from("test0"), vec![start_is_start.clone(), end_is_start.clone()]);
        test_affected_layers.insert(String::from("test0"), vec![start_is_start.clone(), end_is_start.clone()]);
        let result = connection_algorithm_legacy(true, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(1));

        let x1_values = vec![1.0, 2.0, 3.0, 5.0, 6.0]; 
        let y1_values = vec![1.0, 1.0, 1.0, 3.0, 3.0];
        let polyline3 = PolyLine::new(false, x1_values, y1_values);
        expected.insert(String::from("test0"), vec![polyline3.clone()]);

        assert_eq!(result, expected);

        
        //remove the data from this test so it do not interfere with later tests
        test_layers.remove("test0");
        test_affected_layers.remove("test0");
        expected.remove("test0");


        //Test case 1: Close with it's own polyline => is closed from false to true
        test_layers.insert(String::from("test1"), vec![polyline1.clone()]);
        test_affected_layers.insert(String::from("test1"), vec![polyline1.clone()]);
        let result = connection_algorithm_legacy(true, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));


        let x1_values = vec![1.0, 2.0, 2.0, 2.0, 1.0]; 
        let y1_values = vec![1.0, 1.0, 2.0, 3.0, 3.0];
        let polyline1 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test1"), vec![polyline1.clone()]);

        assert_eq!(result, expected);

        //Test case 2: Extend: Start is start = True, End is start = True
        test_layers.insert(String::from("test2"), vec![start_is_start.clone(), end_is_start.clone()]);
        test_affected_layers.insert(String::from("test2"), vec![start_is_start.clone(), end_is_start.clone()]);
        let result = connection_algorithm_legacy(true, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

    
        let x1_values = vec![1.0, 2.0, 3.0, 5.0, 6.0]; 
        let y1_values = vec![1.0, 1.0, 1.0, 3.0, 3.0];
        let polyline3 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test2"), vec![polyline3.clone()]);

        assert_eq!(result, expected);

        //Test case 3: Extend: Start is start, end is end
        test_layers.insert(String::from("test3"), vec![start_is_start.clone(), end_is_end.clone()]);
        test_affected_layers.insert(String::from("test3"), vec![start_is_start.clone(), end_is_end.clone()]);
        let result = connection_algorithm_legacy(true, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        
        let x1_values = vec![6.0, 5.0, 3.0, 2.0, 1.0]; 
        let y1_values = vec![3.0, 3.0, 1.0, 1.0, 1.0];
        let polyline4 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test3"), vec![polyline4.clone()]);

        assert_eq!(result, expected);

        //Test case 5: Extend: Start is end, end is start
        test_layers.insert(String::from("test4"), vec![start_is_end.clone(), end_is_start.clone()]); 
        test_affected_layers.insert(String::from("test4"), vec![start_is_end.clone(), end_is_start.clone()]);
        let result = connection_algorithm_legacy(true, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        let x1_values = vec![1.0, 2.0, 3.0, 5.0, 6.0]; 
        let y1_values = vec![1.0, 1.0, 1.0, 3.0, 3.0];
        let polyline5 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test4"), vec![polyline5.clone()]);

        assert_eq!(result, expected);


        //Test case 6: Extend: Start is end, end is end
        test_layers.insert(String::from("test5"), vec![start_is_end.clone(), end_is_end.clone()]); 
        test_affected_layers.insert(String::from("test5"), vec![start_is_end.clone(), end_is_end.clone()]);
        let result = connection_algorithm_legacy(true, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        let x1_values = vec![6.0, 5.0, 3.0, 2.0, 1.0]; 
        let y1_values = vec![3.0, 3.0, 1.0, 1.0, 1.0];
        let polyline6 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test5"), vec![polyline6.clone()]);

        assert_eq!(result, expected);

        //Test case 7: Add new layers to test_layers, BUT NOT in affected_layers => 
        //Layers not added in affected, should not be closed
        let x_values = vec![10.0, 15.0, 14.0]; 
        let y_values = vec![3.0, 3.0, 2.0];
        let not_affected1 = PolyLine::new(false, x_values, y_values);

        let x_values = vec![16.0, 15.0, 14.0]; 
        let y_values = vec![3.0, 3.0, 2.0];
        let not_affected2 = PolyLine::new(false, x_values, y_values);

        //Add two lines into to different layers
        test_layers.insert(String::from("test6"), vec![not_affected1.clone()]);
        test_layers.insert(String::from("test7"), vec![not_affected2.clone()]);

        //Add the exact same lines into expected => no changes should be made on the lines because they are not affected
        expected.insert(String::from("test6"), vec![not_affected1.clone()]);
        expected.insert(String::from("test7"), vec![not_affected2.clone()]);

        let result = connection_algorithm_legacy(true, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        assert_eq!(result, expected);


        
    }
    #[test]
    fn test_connect_polylines(){
        //Create a Sample data set
        //BTreeMap
        let mut test_layers: BTreeMap<String, Vec<PolyLine>> = BTreeMap::new();
        let mut test_affected_layers: BTreeMap<String, Vec<PolyLine>> = BTreeMap::new();

        //Random line
        let x1_values = vec![1.0, 2.0, 2.0, 2.0, 1.0]; 
        let y1_values = vec![1.0, 1.0, 2.0, 3.0, 3.0];
        let polyline1 = PolyLine::new(false, x1_values, y1_values);

        //Start is start
        let x2_values = vec![1.0, 2.0, 3.0]; 
        let y2_values = vec![1.0, 1.0, 1.0];
        let start_is_start = PolyLine::new(false, x2_values, y2_values);

        //Start is end
        let x5_values = vec![3.0, 2.0, 1.0]; 
        let y5_values = vec![1.0, 1.0, 1.0];
        let start_is_end = PolyLine::new(false, x5_values, y5_values);

        //End is start
        let x3_values = vec![4.0, 5.0, 6.0]; 
        let y3_values = vec![2.0, 3.0, 3.0];
        let end_is_start = PolyLine::new(false, x3_values, y3_values);

        //End is end
        let x4_values = vec![6.0, 5.0, 4.0]; 
        let y4_values = vec![3.0, 3.0, 2.0];
        let end_is_end = PolyLine::new(false, x4_values, y4_values);

        let mut expected: BTreeMap<String, Vec<PolyLine>> = BTreeMap::new();

        //Test case 0: Only 1 iteration => line should give correct values, but is_closed = false
        test_layers.insert(String::from("test0"), vec![start_is_start.clone(), end_is_start.clone()]);
        test_affected_layers.insert(String::from("test0"), vec![start_is_start.clone(), end_is_start.clone()]);
        let result = connection_algorithm_legacy(false, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(1));

        let x1_values = vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0]; 
        let y1_values = vec![3.0, 3.0, 2.0, 1.0, 1.0, 1.0];
        let polyline3 = PolyLine::new(false, x1_values, y1_values);
        expected.insert(String::from("test0"), vec![polyline3.clone()]);

        assert_eq!(result, expected);

        
        //remove the data from this test so it do not interfere with later tests
        test_layers.remove("test0");
        test_affected_layers.remove("test0");
        expected.remove("test0");
        

        //Test case 1: Close with it's own polyline => is closed from false to true
        test_layers.insert(String::from("test1"), vec![polyline1.clone()]);
        test_affected_layers.insert(String::from("test1"), vec![polyline1.clone()]);
        let result = connection_algorithm_legacy(false, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        let x1_values = vec![1.0, 2.0, 2.0, 2.0, 1.0]; 
        let y1_values = vec![1.0, 1.0, 2.0, 3.0, 3.0];
        let polyline1 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test1"), vec![polyline1.clone()]);

        assert_eq!(result, expected);

        //Test case 2: Connect: Start is start, end is start
        test_layers.insert(String::from("test2"), vec![start_is_start.clone(), end_is_start.clone()]);
        test_affected_layers.insert(String::from("test2"), vec![start_is_start.clone(), end_is_start.clone()]);
        let result = connection_algorithm_legacy(false, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        let x1_values = vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0]; 
        let y1_values = vec![3.0, 3.0, 2.0, 1.0, 1.0, 1.0];
        let polyline3 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test2"), vec![polyline3.clone()]);

        assert_eq!(result, expected);

        //Test case 3: Connect: Start is start, end is end
        test_layers.insert(String::from("test3"), vec![start_is_start.clone(), end_is_end.clone()]);
        test_affected_layers.insert(String::from("test3"), vec![start_is_start.clone(), end_is_end.clone()]);
        let result = connection_algorithm_legacy(false, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        
        let x1_values = vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0]; 
        let y1_values = vec![3.0, 3.0, 2.0, 1.0, 1.0, 1.0];
        let polyline4 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test3"), vec![polyline4.clone()]);

        assert_eq!(result, expected);
        
        //Test case 4: Connect: Start is end, end is start
        test_layers.insert(String::from("test4"), vec![start_is_end.clone(), end_is_start.clone()]); 
        test_affected_layers.insert(String::from("test4"), vec![start_is_end.clone(), end_is_start.clone()]);
        let result = connection_algorithm_legacy(false, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        let x1_values = vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0]; 
        let y1_values = vec![3.0, 3.0, 2.0, 1.0, 1.0, 1.0];
        let polyline5 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test4"), vec![polyline5.clone()]);

        assert_eq!(result, expected);

        //Test case 5: Connect: Start is end, end is end
        test_layers.insert(String::from("test5"), vec![start_is_end.clone(), end_is_end.clone()]); 
        test_affected_layers.insert(String::from("test5"), vec![start_is_end.clone(), end_is_end.clone()]);
        let result = connection_algorithm_legacy(false, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        let x1_values = vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0]; 
        let y1_values = vec![3.0, 3.0, 2.0, 1.0, 1.0, 1.0];
        let polyline6 = PolyLine::new(true, x1_values, y1_values);
        expected.insert(String::from("test5"), vec![polyline6.clone()]);

        assert_eq!(result, expected);


        //Test case 6: Add new layers to test_layers, BUT NOT in affected_layers => 
        //Layers not added in affected, should not be closed
        let x_values = vec![10.0, 15.0, 14.0]; 
        let y_values = vec![3.0, 3.0, 2.0];
        let not_affected1 = PolyLine::new(false, x_values, y_values);

        let x_values = vec![16.0, 15.0, 14.0]; 
        let y_values = vec![3.0, 3.0, 2.0];
        let not_affected2 = PolyLine::new(false, x_values, y_values);

        //Add two lines into to different layers
        test_layers.insert(String::from("test6"), vec![not_affected1.clone()]);
        test_layers.insert(String::from("test7"), vec![not_affected2.clone()]);

        //Add the exact same lines into expected => no changes should be made on the lines because they are not affected
        expected.insert(String::from("test6"), vec![not_affected1.clone()]);
        expected.insert(String::from("test7"), vec![not_affected2.clone()]);

        let result = connection_algorithm_legacy(false, &test_layers, &test_affected_layers, &Some(100.0), &Some(180), &Some(10));

        assert_eq!(result, expected);


    }

}